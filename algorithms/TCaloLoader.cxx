// Authors: Lizette Lamers and Remco de Boer
// Date: June 8th, 2018
// For NIKHEF Project 2018

/* === CLASS DESCRIPTION =======
	This algorithm reads the data file that is generated by the calorimeter. This data file is just a long text file that defines an arbitrary number of "calo events" that each contain 1024 values. These values have to be integrated to obtain the cumulative energy detected by the calorimeter in an event. In this algorithm, this is done by computing the sum of its histogram. There is a seperate algorithm for computing the energy with a fit.
*/

// === INCLUDES =======
	#include "TCaloLoader.h"
	#include <iostream>
	using namespace std;
	using namespace NIKHEFProject;

// === ALGORITHM STEP FUNCTIONS =======

	// INITIALISE FUNCTION: opens the text file and creates histogram
	void TCaloLoader::Initialise()
	{
		// Open file stream and check if open
		fFileStream.open(pCaloFileName);
		if(!fFileStream.is_open()) {
			cout << "  File \"" << pCaloFileName << "\" does not exist!" << endl;
			return;
		} else cout << "  Opened calo file \"" << pCaloFileName << "\"" << endl;
		// Determine number of events
		DetermineNEvents();
		cout << "  --> contains " << pTotalFiles << " events" << endl;
	}

	// RUN FUNCTION: read the next calo event in the text file and create a TCaloEvent from it
	StatusCode TCaloLoader::Run()
	{
		// Return FINISHED if file does not exist
		if (!fFileStream.is_open()) {
			if(fDebug) cout << endl << "File \"" << pCaloFileName << "\" does not exist" << endl;
			return Finished;
		}
		// Return FINISHED if end of file is reached
		if(fFileStream.eof()) {
			if(fDebug) cout << endl << "End of file \"" << pCaloFileName << endl;
			return Finished;
		}
		// Return SUCCESS if a calo event could be read from position in file stream
		if(LoadCaloEvent()) return Success;
		else Finished;
		// Return NODATA if failure at position in file stream
		return NoData;
	}

	// FINALISE FUNCTION: merely closes file stream of the calo data file
	void TCaloLoader::Finalise() {
		fFileStream.close();
		if(fDebug) cout << "Closed file \"" << pCaloFileName << "\"" << endl;
	}

// === PRIVATE FUNCTIONS =======
	// Function that determines the number of events in a txt file from the calorimeter
	UInt_t TCaloLoader::DetermineNEvents()
	{
		pTotalFiles = 0;
		ifstream in(pCaloFileName);
		TString buffer;
		while(in.getline(pBuffer,pBufferSize)) {
			buffer = pBuffer;
			if( buffer.Contains("BoardID: 31") ) ++pTotalFiles;
		}
		return pTotalFiles;
	}

	// Function that continues reading from current position in the ifstream and and creates a new TCaloEvent from the data in this file.
	Bool_t TCaloLoader::LoadCaloEvent()
	{
		TString buffer;
		// Check if file stream is still ok
		// if(!fFileStream.good()) {
		// 	if(fDebug) cout << "Problem reading \"" << pCaloFileName << "\"" << endl;
		// 	return false;
		// }
		// Read record length
		fFileStream.getline(pBuffer,pBufferSize,':'); // check words "Record Length"
		if(strcmp(pBuffer,"Record Length")) {
			if(fDebug) cout << endl << "Record Length line incorrect format: " << pBuffer << endl;
			return false;
		}
		fFileStream.get(); // read ':'
		fFileStream >> fNCaloPoints;
		fFileStream.getline(pBuffer,pBufferSize); // finish line
		// Check line "BoardID"
		fFileStream.getline(pBuffer,pBufferSize);
		buffer = pBuffer; // added because of some sort of unicode
		if( !buffer.Contains("BoardID: ") ) {
			if(fDebug) cout << endl << "Board ID line incorrect format: " << pBuffer << endl;
			return false;
		}
		// Check line "Channel"
		fFileStream.getline(pBuffer,pBufferSize);
		buffer = pBuffer; // added because of some sort of unicode
		if(!buffer.Contains("Channel: ")) {
			if(fDebug) cout << endl << "Channel line incorrect format: " << pBuffer << endl;
			return false;
		}
		// Read event number
		fFileStream.getline(pBuffer,pBufferSize,':'); // check words "Event Number"
		buffer = pBuffer; // added because of some sort of unicode
		if(!buffer.Contains("Event Number")) {
			if(fDebug) cout << endl << "Event Number line incorrect format: " << pBuffer << endl;
			return false;
		}
		fFileStream.get(); // read ':'
		fFileStream >> fEventNumber;
		fFileStream.getline(pBuffer,pBufferSize); // finish line
		// Check line "Pattern"
		fFileStream.getline(pBuffer,pBufferSize);
		buffer = pBuffer; // added because of some sort of unicode
		if(!buffer.Contains("Pattern: 0x0000")) {
			if(fDebug) cout << endl << "Pattern line incorrect format: " << pBuffer << endl;
			return false;
		}
		// Read timestamp and add to fCalorimeter
		fFileStream.getline(pBuffer,pBufferSize,':'); // check words "Trigger Time Stamp"
		buffer = pBuffer; // added because of some sort of unicode
		if(!buffer.Contains("Trigger Time Stamp")) {
			if(fDebug) cout << endl << "Timestamp line incorrect format: " << pBuffer << endl;
			return false;
		}
		fFileStream.get(); // read ':'
		fFileStream >> fTimestamp;
		fFileStream.getline(pBuffer,pBufferSize); // finish line
		// Check line "DC offset (DAC)"
		fFileStream.getline(pBuffer,pBufferSize);
		buffer = pBuffer; // added because of some sort of unicode
		if(!buffer.Contains("DC offset (DAC): 0x1999")) {
			if(fDebug) cout << endl << "DC offset line incorrect format: " << pBuffer << endl;
			return false;
		}
		// Create TCaloEvent
		fCaloEvent = new TCaloEvent(fEventNumber,fTimestamp,fNCaloPoints);
		Int_t zero_counter = 0;
		Int_t true_counter = 0;
		Int_t lower_counter = 0;
		Int_t late_counter = 0;
		Double_t value_buffer = -100;
		bool peak_reached = false;
		Int_t second_peak_counter = 0;
		Double_t peak_value = 0;
		// Read all values of calo event (usually 1024)
		bool Succesful_event = false;
		for(Int_t i=0; i<fNCaloPoints; ++i) {
			// read value
			fFileStream >> fValue;
			// flip value if not first value
			if(i) {
				fValue -= fCaloEvent->GetValue(0);
				fValue *= -1;
			}
			if(fValue == 0) zero_counter++;
			if(fValue > 100) {
				true_counter++;
				if(i > 250) late_counter++;
				if(i%25 == 0){
					if(fValue < value_buffer){
						if(value_buffer > peak_value && peak_reached == false) {
							peak_value = value_buffer;
							peak_reached = true;
						}	
					}
					if(peak_reached == true && fValue > value_buffer) {
						if(fValue/peak_value > 0.4) second_peak_counter++;
					}
				}

			}
			if(i > 250 && fValue < 0) lower_counter++;
			// store value
			fCaloEvent->SetValue(i,fValue); // puts value fFileStream list
			if(i%25 == 0) value_buffer = fValue;
		}
		if(true_counter > 10) Succesful_event = true; //criteria to root out bad events
		if(true_counter == late_counter) Succesful_event = false; //if event started to late
		if(1024-zero_counter < 700) Succesful_event = false; //700 entries at least
		if(lower_counter > 0) Succesful_event = false; //if event started to early
		if(second_peak_counter > 0 && Succesful_event == true) Succesful_event = false; //if second peak in spectrum

		fFileStream.getline(pBuffer,pBufferSize); // finish line

		if(Succesful_event) {
			fClipboard->Put(fCaloEvent);
			fCaloEvent->SetValue(0,0.); // was skipped in previous loop
			// Set energy
			fCaloEvent->SetEnergy(fCaloEvent->GetHistogram()->Integral(1,fNCaloPoints+1));
		} else{
			delete fCaloEvent;
		}
		return true;
	}